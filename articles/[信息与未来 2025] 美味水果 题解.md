[题目传送门](files/信息与未来%202025.pdf)（PDF）
## 题目大意
给定一个正整数序列 $x$，要求每次从中取出一个数，将这个数加到答案中，然后将序列中其他的数全部开根号取整，直到序列为空，求得到的答案的最大值。

数据范围：$1 \leq n \leq 10^5, 1 \leq x_i \leq 10^9$。

## 思路
贪心，首先将序列排序，每次取出最大的数，然后将其他的数开根号取整，重复上述过程，直到序列为空。此做法的时间复杂度为 $O(n^2)$，所以要考虑优化。

可以发现，**$10^9$ 在开根号取整 $5$ 次后会变成 $1$**，所以我们可以将排序后最大的 $5$ 个数按照上述方法进行计算后，剩下的直接当作 $1$ 加入到答案中即可，此做法的最快时间复杂度为 $O(n)$（不排序，直接找出前 $5$ 大的数），使用排序的方法找出前 $5$ 大的方法时间复杂度为 $O(n log n)$，实际用时和直接比较出前 $5$ 大差不多，在遇到某些数据时用时反而更少。

## 代码
```cpp
#include <bits/stdc++.h>
#define int long long // 防止数据溢出
using namespace std;
const int N = 1e5 + 5, M = 5; // N 是数组的最大长度，M 是最大需要处理的数的个数
int a[N];					  // 存储输入的序列
signed main() {
	int n, ans = 0;	   // n 是序列长度，ans 是最终的答案
	scanf("%lld", &n); // 输入序列长度
	for (int i = 1; i <= n; i++) {
		scanf("%lld", a + i); // 输入序列中的每个数
	}
	// 对序列进行降序排序，lambda 函数定义比较规则
	sort(a + 1, a + n + 1, [](int x, int y) { return x > y; });
	// 处理前 M 大的数
	for (int i = 1; i <= min(M, n); i++) {
		ans += a[i]; // 将当前最大的数加到答案中
		// 对其他数开根号取整
		for (int j = i + 1; j <= min(M, n); j++) {
			a[j] = sqrt(a[j]); // 浮点数存储在 int 类型的变量中会自动取整
		}
	}
	// 剩下的数都是 1，直接加到答案中
	ans += max(0ll, n - M); // 避免 n < M 时出现负数
	printf("%lld", ans);	// 输出答案
	return 0;
}
```