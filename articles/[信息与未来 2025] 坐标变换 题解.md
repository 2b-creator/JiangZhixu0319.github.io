[题目传送门](files/信息与未来%202025.pdf)（PDF）
## 题目大意
给定一个 $n \times m$ 的网格，其中每个元素依次为从上到下，从左到右从 $1$ 开始编号，已知网格中一个编号为 $k$ 的格子，求将网格顺时针旋转 $45^\circ$ 后，编号为 $k$ 的格子的坐标。

数据范围：$1 \leq n, m \leq 32768$

## 思路
可以理解为一道找规律题。首先我们需要先算出来旋转之前的坐标，我们假设旋转之前的坐标为 $(x_1, y_1)$，旋转之后的坐标为 $(x_2, y_2)$。

可以发现，当 $x_1$ 变大时，$x_2$ 会变大，当 $y_1$ 变大时，$x_2$ 也会变大。

当 $x_1$ 变大时，$y_2$ 会变小，当 $y_1$ 变大时，$y_2$ 会变大。

通过代入一些值，我们就可以得出规律 $x_2 = x_1 + y_1 - 1, y_2 = n - x_1 + y_1$。

## 代码
```cpp
#include <bits/stdc++.h>
#define int long long // 防止数据溢出
using namespace std;
signed main() {
	int n, m, k, x, y;
	// 输入网格的行数 n，列数 m，以及目标编号 k
	scanf("%lld%lld%lld", &n, &m, &k);
	// 计算原始坐标 (x, y)
	x = (k - 1) / m + 1;
	y = (k - 1) % m + 1;
	// 计算旋转后的坐标 (x + y - 1, n - x + y)
	// 根据题目规律推导的公式
	printf("%lld %lld", x + y - 1, n - x + y);
	return 0;
}
```